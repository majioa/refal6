************************************************************************
*    R E F A L - 6         Copyright (C) 1992 by Arkady Klimov         *
************************************************************************
*       gentab.ref  - standalone executable file                       *
*                     generate modules rfelst.c & rfinit.c             *
*                                                                      *
*  Call:    ri gentab [[[builtin.fls] rfelst.c] rfinit.c]              *
*  filefrom = builtin.fls, a function list file                        *
*             which contains lines in the form:                        *
*               (<function name> [<format>]                            *
*                     ( <type> <C-fun_name> [<C-format>]))             *
*             or                                                       *
*               (<module name> <C-init_fun_name> [<C-term_fun_name>])  *
*             Program takes <function_name>, <C-fun_name>              *
*             from lines where <format> is empty and <type> is C       *
*             and uses list of these pairs to generate module rfelst.c *
*             Lines with module names are used to generate functions   *
*             rf_inist() and rf_termst() which are executed before and *
*             after the call to RF_GO.                                 *
*  fileto1  = rfelst.c, a module used in RASL-interpreter              *
*             as a builtin function table.                             *
*             It is written in C and consists of three parts:          *
*             1) vector of names,                                      *
*             2) list of function declarations,                        *
*             3) vector of pointers to functions                       *
*  fileto2  = rfinit.c, a module used in rfmain.c, contains two        *
*             functions:                                               *
*             1) rf_inist()                                            *
*             2) rf_termst()                                           *
************************************************************************
MAIN = <Do <Argopt 1 'builtin.fls'>
                <Argopt 2 'rfelst.c'>
                <Argopt 3 'rfinit.c'> >;

Argopt  sN eA , <ARG sN> : {
   = (eA);
   eB = (eB);
   };

Do  (e.In) (e.Out1) (e.Out2) , <OPEN_FILE 3 e.In R> : {
       F = <PRINTLN "Can\'t open input file " e.In> <EXIT 10>;
       T , <OPEN_FILE 4 e.Out1 W> : {
       F = <PRINTLN "Can\'t open output file " e.Out1> <EXIT 10>;
       T , <OPEN_FILE 5 e.Out2 W> : {
       F = <PRINTLN "Can\'t open output file " e.Out2> <EXIT 10>;
       T = <Gentab <Inpall>>;
       }}};

Inpall , <INPEXP 3> : { = ; tX = tX <Inpall> };

* Select builtin function declaration
Sfunc { (sR (C sC)) = (sR sC); tA = };

* Select module init/term declaration
Smod { (sR sI eT) = (sR sI eT); tA = };




Gentab { eS = <Puts 4
("/************************************************************************/")
("/*   R E F A L - 6         Copyright (C) 1992 by Arkady Klimov          */")
("/*      !!! This module was generated by GENTAB                         */")
("/*       rfelst.c    - list of built-in functions                       */")
("/************************************************************************/")
()
("#define LOGICAL int")
() >
 <Puts 5
("/************************************************************************/")
("/*   R E F A L - 6         Copyright (C) 1992 by Arkady Klimov          */")
("/*      !!! This module was generated by GENTAB.REF                     */")
("/*       rfinit.c    - initialization/termination functions             */")
("/************************************************************************/")
()
("#define LOGICAL int")
("#define TRUE 1")
>
 <Genfuncs <Map *Sfunc eS>>
 <Genmods <Map *Smod eS>>;
};

Genfuncs { eS = <Gentxt 4 eS> <Genext 4 eS> <Genptr 4 eS> };
Genmods  { eS = <Genext 5 eS> <Genini 5 eS> <Genterm 5 eS> };

Gentxt { sC eS = <Puts sC
 ("char * blttxt[] = {")
   <Del-last-comma <Gtxt 0 eS>>
 ("};")
 ("int bltcnt = sizeof(blttxt)/sizeof(char *);")
>};
Gtxt {
   sn =;
   sn (sR sC) eX = ('   /*'<Asymb sn> ' */  \"'<SpecSym <EXPLODE sR>>'\",')
           <Gtxt <ADD sn 1> eX> ;
   };
SpecSym {
   e1 '\\' e2 = e1 '\\\\' <SpecSym e2>;
   e1 = e1;
   };

Genext  sC eS = <Puts sC () <Map &Gext eS> ()>;
Gext {
    (sR) =;
    (sR sC eX) = ('extern LOGICAL 'sC'();') <Gext (sR eX)>;
    };

Genptr  sC eS = <Puts sC
 ("LOGICAL (* rf_subr[])() = {")
   <Del-last-comma <Map &Gptr eS>>
 ("};") >;
Gptr (sR sC) eX = ('        'sC',') ;

Genini sC eS = <Puts sC ()
 ("LOGICAL rf_inist()") ('{')
    <Map &Gini eS>
 ("return(TRUE);") ('};') >;
Gini (sR sI eT) eX = (sI '();');

Genterm { sC eS = <Puts sC ()
 ("LOGICAL rf_termst()") ('{')
    <Gterm eS>
 ("return(TRUE);") ('};')
>};
Gterm {
   =;
   eX (sR sI) = <Gterm eX>;
   eX (sR sI sT) = (sT '();') <Gterm eX>;
   };

Del-last-comma ex (ey ',') = ex (ey);

Asymb { sN, '  ' <SYMB sN> : e0 s1 s2 s3 = s1 s2 s3 };
Puts { sC eA = <Map (&Put sC) eA> };
Put sC (eA) = <PRINTLN! sC eA>;

Map {
  tf ta eb = <Apply tf ta> <Map tf eb>;
  tf =;
  };

Apply { sf ea = <sf ea>; (ef) ea = <Apply ef ea> };

$EXEC SHIFT *SYSARG 1 -1;
$EXEC MAIN;