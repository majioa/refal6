
         Функции работы с экранами и окнами на них
         ═════════════════════════════════════════

     При  описании функций  по  работе  с экранами  и окнами
будет использоваться  понятие объекта класса  SLIDE. SLIDE -
это обобщенный (первичный) класс, свойства и методы которого
будут  наследоваться  (в  смысле   ООП)  его  подклассами  -
классами-наследниками.  Сам класс  SLIDE является подклассом
класса  RECT -  "прямоугольник"  и  класса CHANNEL  - "канал
последовательного  ввода/вывода". Оъекты  класса SLIDE  (или
его  подклассов)   в  дальнейшем  будут   называться  просто
"слайдами".

             *Привязка, прямоугольник слайда*

     Каждый   слайд   ссылается   на   некоторую   память  -
видеобуфер, где хранятся символы  с их цветовыми атрибутами.
При  создании  слайду   ставится  в  соответствие  некоторый
целочисленный  прямоугольник  (sX  sY  sW  sH)  в  некоторой
"глобальной"   системе  координат.   Это  позволяет   каждой
"ячейке"  видеобуфера приписать  двумерные координаты,  т.е.
выполнить привязку.

     При   этой   привязке    первая   ячейка   видеобуфера,
соответствующая  левому верхнему  углу, имеет  координаты --
(sX  sY), а  размер видеобуфера  должен позволять  запомнить
sW*sH  символов,  что  и  обеспечивается процедурой создания
слайда. Если sW или sH  меньше либо равны нуля, то создается
"пустой" слайд.

                      *Текущая позиция*

     Кроме символов в слайде  запоминается текущая позиция -
(s.PosX  s.PosY),  которая   используется  при  посимвольном
вводе/выводе  в  слайд.  Текущая  позиция  -  это пара целых
чисел,  определенная в  глобальной системе  координат (а  не
относительно его левого верхнего угла слайда).

                 *Текущий цветовой атрибут*

     Также запоминается и  текущий цветовой атрибут, который
приписывается выводимому  в слайд символу,  а при чтении  из
слайда устанавливается равным значению атрибута прочитанного
символа.

     Для компьютеров класса  IBM PC XT/AT значением атрибута
"цвет   символа"  является   целое  число   от  0   до  255,
соответствующее  кодировке  цветовых  атрибутов  символов  в
видеопамяти.

                      *Позиция курсора*

     Слайд  моделирует экран  дисплея  или  окно на  нем. На
экране обычно  в какой-то позиции  виден курсор определенной
формы.  Слайд, иммитируя  экран дисплея,  тоже содержит свой
курсор с  позицией (s.CurX s.CurY)  и типом s.CurT.  Позиция
курсора, так же как и  текущая позиция, является парой целых
чисел, определенных в глобальной системе координат, и они не
обязаны всегда указывать на какой-то символ "внутри" слайда.

                        *Тип курсора*

     Тип курсора  - целое число,  определяющее его форму  на
экране. Для  текстовых режимов на компьютерах  класса IBM PC
XT/AT значение типа определяется по формуле:

     256 * стартовая_линия_курсора_в_матрице_знакоместа +
           конечная_линия_курсора_в_матрице_знакоместа,

где  линии  в  матрице  знакоместа  считаются  сверху  вниз,
начиная с 0.

     Тип  "погашенного" (невидимого)  курсора равен  256*32.
Если же требуется изменить  только местоположение курсора не
меняя при этом его тип, то функции SLIDE_CURS_SET в качестве
типа курсора следует передать число -1 - "старый курсор".

                      *Владелец слайда*

     Все слайды  можно разбить на две  категории первичные и
вторичные.  Вторичные  слайды  получаются  путем "вырезания"
прямоугольной области из другого слайда,  т.е. они по сути -
подслайды.

     Первичные слайды  независимы между собой,  изменение же
состояния  вторичного  слайда  обычно  приводит  к изменению
состояния  его владельца.  Владелец слайда  всегда первичный
слайд,  даже если  вторичный слайд  создавался как  подслайд
другого вторичного подслайда (ссылка на владельца слайда как
бы  спрямляется).  Считается,  что  первичный слайд является
владельцем самого себя.

     Обычно  подслайд  не  имеет  собственного видеобуфера и
использует   видеобуфер   своего   владельца,   и  изменение
положения или типа  курсора подслайда влечет соответствующие
изменения  у владельца.  Текущая позиция  и текущий цветовой
атрибут у всех слайдов независимы.

     Сразу  после  создания  подслайда  слайда  их  привязки
соответствует,  но,  в  дальнейшем   же  их  привязки  могут
независимо изменяться. Это означает, что одна и та же ячейка
видеобуфера  может иметь  разные координаты  в слайде  и его
подслайде.

     Привязка  изменяется  с  помощью  функции SLIDE_XY_SET,
получающей  в качестве  параметров новые  значения координат
левого  верхнего  угла  слайда.  При  этом  функция изменяет
соответствующим  образом  и  координаты  текущей  позиции  и
позиции курсора в  слайде так, чтобы они указывали  на те же
символы в видеобуфере, что и до выполнения функции.

     Если же после какого-то  числа вызовов этой функции для
подслайда и его владельца  требуется узнать какие же текущие
координаты    первой     ячейки    видеобуфера    подслайда,
рассматриваемой  как  ячейка  видеобуфера  его владельца, то
следует  вызвать  функции  SLIDE_OWNER,  которая  кроме этих
координат выдаст еще и ссылку на самого владельца.


                      Функции-методы
                      ══════════════

     Далее подробно описывается функции-методы классов:

     SLIDE  - виртуальный экран в  памяти - он же обобщенный
              слайд - подкласс классов RECT и CHANNEL;

     SCREEN - экран дисплея  в текстовом режиме  -  подкласс
              класса SLIDE.

     При описании функций-методов часто будет использоваться
параметр   t.rect,   ограничивающий   действие   функции  на
пересечение  прямоугольника, задаваемого  этим параметром, и
прямоугольника слайда, к  которому применяется данный метод.
В качестве  t.rect  может  подставляться  либо явно заданный
прямоугольник  (sX  sY  sW  sH)  либо  объект класса RECT. В
частности, может быть подставлен любой слайд.


                 Функции создания объектов
                 ─────────────────────────

     <SLIDE_MAKE    s.object t.rect>           == s.object
     <SCREEN_MAKE   s.object s.page>           == s.object
     <MAKE_SUBSLIDE s.object s.slide [t.rect]> == s.object
где
     s.object - в вызове функции: ссылка  на  пустой объект;
                   как результат: та же ссылка, но уже на
                                  созданный объект;
     t.rect   - ссылка на объект класса RECT или
                (sX sY sW sH);
     s.page   - номер видеостраницы, начиная с 0;
     s.slide  - ссылка на слайд, но отличная от s.object.

     SLIDE_MAKE создает виртуальный экран - первичный слайд,
захватывая   для  видеобуфера   динамическую  память.  Число
символов   определяется   произведением   ширины   и  высоты
прямоугольника  t.rect.

*Привязка*  слайда соответствует  прямоугольнику t.rect  (даже
если  прямоугольник пустой).  Видеобуфер никакими значениями
не заполняется.

*Текущая позиция*,
*Позиция курсора* указывает на левый верхний угол слайда.

*Текущий атрибут* равен 7 (светло-серый цвет).

*Тип курсора* равен -1 ("старый" курсор).

*Владелец* - сам слайд s.object.

     SCREEN_MAKE     создает    объект     класса    SCREEN,
соответствующий  видеостранице  с  номером  s.page. При этом
память  видеостраницы  и  есть  видеобуфер  объекта. Поэтому
запись в  него тут же вызывает  изменения на экране дисплея,
если соответствующая видеостраница является активной.
@CP 4

*Привязка*  слайда соответствует  прямоугольнику (0  0 sW sH),
где  sW, sH  - ширина  и высота  экрана дисплея  в символах,
определяемых по текущему видеорежиму.

*Текущая позиция* указывает на левый верхний угол экрана.

*Текущий атрибут* равен 7 (светло-серый цвет).

*Позиция курсора*,
*Тип курсора* соответствует курсору на экране дисплея.

*Владелец* - сам экран s.object.

     Автоматически создается и экспортируется объект *STDSCR
класса   SCREEN,   соответствующий   нулевой  видеостранице.

     MAKE_SUBSLIDE  создает  подслайд  слайда  s.slide.  Это
полиморфный  конструктор  и  класс  получившегося  подслайда
зависит от самого слайда. Известно одно, что этот класс либо
совпадает   с    классом   s.slide,   либо    является   его
классом-наследником.  При этом  должны выполняться следующие
условия:

*Привязка*  слайда  соответствует  пересечению  прямоугольника
t.rect (если он указан) и прямоугольника слайда s.slide. Для
классов  SLIDE  и  SCREEN  никакая  дополнительная память не
захватывается, а используется напрямую видеобуфер s.slide.

*Текущая позиция*,
*Позиция курсора* указывает на левый верхний угол подслайда.

*Текущий атрибут* равен текущему атрибуту слайда s.slide.

*Тип курсора* равен -1 ("старый" курсор).

*Владелец* устанавливается равным владельцу s.slide.

     MAKE_SUBSLIDE всегда создает вторичный слайд.


             Функции прямого доступа к слайду
             ────────────────────────────────

     <SLIDE_FILL s.slide s.char s.attr [t.rect]> ==
     <SLIDE_CORR s.slide s.bool s.attr [t.rect]> ==
     <SLIDE_COPY s.slide s.slide1 [t.rect]>      ==
     <SLIDE_SWAP s.slide s.slide1 [t.rect]>      ==
где
     s.slide  - ссылка на слайд, к которому применяется
                данный метод;
     s.slide1 - ссылка на слайд (2 параметр);
     s.char   - символ-литера;
     s.attr   - символ-число - цветовой атрибут;
     s.bool   - символ-число, определяющее булевскую функцию
                преобразования атрибутов;
     t.rect   - ссылка  на объект класса RECT или
                (sX sY sW sH).

     SLIDE_FILL - заполняет  символом   s.char  с   цветовым
атрибутом  s.attr  ту   часть  видеобуфера  слайда  s.slide,
которая  определяется пересечением  прямоугольника слайда  и
прямоугольника t.rect.

     SLIDE_CORR - корректирует  цветовые  атрибуты  символов
той части видеобуфера  слайда s.slide, которая соответствует
пересечению  прямоугольника слайда  и прямоугольника t.rect.
При  этом  с  цветовым  атрибутом  q  каждого символа в этом
пересечении выполняется операция: q := |s.bool| (q, s.attr),
где   |s.bool|   -   функция   преобразующая   атрибут  q  и
определяемая числом s.bool.

     Код s.bool строится по следующим правилам:

биты 0-3 - номер основной булевской (побитовой) функции:

           14:  q := q  OR s.attr
            6:  q := q XOR s.attr
            8:  q := q AND s.attr
            5:  q := NOT s.attr
           10:  q := s.attr
            3:  q := NOT q
           12:  q := q

бит 4    -  1:  дополнительно  над  результатом  выполняется
                побитовое отрицание;
            0:  отрицание результата не выполняется;

бит 5    -  1:  дополнительно  над  результатом  выполняется
                перестановка  группы битов  с 0-го  по 2-й с
                группой  от   4-го  по  6-й.   Эта  операция
                соответствует инвертированию цвета символа;
            0:  перестановка в результате не выполняется.

     Данная функция в основном нужна для построения тени:

            s.bool = 10, s.attr = 7;

или инвертирования цветов:

            s.bool = 32 + 12, s.attr - произвольный.

     SLIDE_COPY  -  копирует  содержимое  видебуфера  слайда
s.slide1 в слайд s.slide. При этом копируется только символы
(с   их   цветовыми   атрибутами),   которые  "попадают"  на
пересечение прямоугольников слайдов и прямоугольника t.rect.

     SLIDE_SWAP - обменивает содержимое видеобуферов слайдов
s.slide и  s.slide1. При этом встречно  копируются только те
символы (с  их цветовыми атрибутами),  которые "попадают" на
пересечение прямоугольников слайдов и прямоугольника t.rect.


          Функции канального ввода/вывода в слайд
          ───────────────────────────────────────

     Класс  SLIDE  является   подклассом  класса  CHANNEL  и
поэтому со  слайдами можно работать  функциями посимвольного
канального ввода/вывода.

     Но есть две существенные особенности:

     1) слайд - это "двумерный" объект и каждый символ в его
        видеобуфере имеет координаты (sX sY);

     2) каждый символ  в слайде  имеет собственный  цветовой
        атрибут.

     Чтобы  управлять  этим  в  описание  слайда введено два
понятия: "текущая позиция" и "текущий атрибут".

     В процессе ввода/вывода осуществляется доступ к символу
видеобуфера  слайда,  на  который  указывает текущая позиция
(при вводе  из слайда он  считывается, при выводе  в слайд -
обновляется).  После  этого   x-координата  текущей  позиции
увеличивается на 1, а текущий атрибут устанавливается равным
цветовому  атрибуту  выводимого  или  только  что введенного
символа.

     Особым образом осуществляется ввод/вывод, когда текущая
позиция находится вне прямоугольного слайда:

при выводе - на 1 увеличивается x-координата текущей позиции
             и устанавливается текущий  атрибут,  содержимое
             видеобуфера не изменяется;
при вводе  - на 1 увеличивается x-координата текущей позиции
             текущий  атрибут  не  изменяется,  а в качестве
             символа  возвращается символ-число, равный -1.

     Вызов <EOF s.slide> для  слайда-канала выдаст слово "T"
тогда, когда  текущая позиция в слайде  такова, что при всех
последующих  операциях  ввода   символа  будет  возвращаться
-1.  Это будет  в  случае,  когда текущая  позиция находится
выше, правее или ниже прямоугольника слайда.

     Для  чтения  и  изменения  значений  текущей  позиции и
текущего атрибута существуют следующие функции:

     <SLIDE_POS_GET  s.slide>        == sX sY
     <SLIDE_POS_SET  s.slide sX sY>  ==
     <SLIDE_ATTR_GET s.slide>        == s.attr
     <SLIDE_ATTR_SET s.slide s.attr> ==
где
     s.slide - ссылка на слайд, к которому применяется
               данный метод;
     s.attr  - символ-число - цветовой атрибут;
     sX sY   - символы-числа - координаты текущей позиции.

     SLIDE_POS_GET  - возвращает два символа-числа  sX и sY,
являющихся координатами текущей позиции в слайде s.slide.

     SLIDE_POS_SET  - устанавливает в слайде x, y-координаты
текущей позиции равными sX и sY соответственно.

     SLIDE_ATTR_GET - возвращает   символ-число  s.attr,
являющееся текущим цветовым атрибутом слайда.

     SLIDE_ATTR_SET - устанавливает   в  слайде   текущий
цветовой атрибут равным s.attr.


                 Функции доступа к курсору
                 ─────────────────────────

     <SLIDE_CURS_GET s.slide> == s.CurX s.CurY s.CurT
     <SLIDE_CURS_SET s.slide s.CurX s.CurY s.CurT> ==
где
     s.slide - ссылка на слайд, к которому применяется
               данный метод;
     s.CurX  - символ-число - x-координата курсора;
     s.CurY  - символ-число - y-координата курсора;
     s.CurT  - символ-число - тип курсора.

     SLIDE_CURS_GET - возвращает  три  символа-числа  s.CurX
s.CurY s.CurT, являющихся x, y-координатой и типом курсора в
слайде.

     SLIDE_CURS_SET - устанавливает в слайде x, y-координаты
и его  тип равными  s.CurX, s.CurY  и s.CurT соответственно.
При этом,  если s.CurT имеет значение  -1 - "старый курсор",
то тип курсора в слайде не изменяется. Далее, если s.CurT не
равен  -1, а  (s.CurX  s.CurY)  не попадает  в прямоугольник
слайда,  то  тип  курсора  устанавливается  равным  значению
невидимого курсора (позиция курсора все равно обновляется).

     Дополнительно, в  объектах класса SCREEN,  если позиция
попадает   в   прямоугольник   экрана,   то   соответственно
устанавливается   положение  "видимого"   курсора.  И   если
страница  экрана  является  активной,  то  его  форма  будет
определяться получившимся  типом курсора. В  частности, если
позиция курсора выходит за границы экрана, то он "погаснет".

     Для  подслайдов, кроме  обычных действий,  определяемых
для   класса   SLIDE,   выполняется   вызов  соответствующей
процедуры   установки   положения   и   типа   курсора   для
слайда-владельца.  При  этом   тип  курсора  берется  равным
получившемуся  типу курсора  в подслайде,  а позиция курсора
пересчитывается   с   учетом    расположения   подслайда   в
слайде-владельце.


             Функции доступа к привязке слайда
             ─────────────────────────────────

     <SLIDE_XY_SET s.slide sX sY> ==
     <SLIDE_OWNER  s.slide>       == s.owner sX sY
где
     s.slide - ссылка на слайд, к которому применяется
               данный метод;
     s.owner - ссылка слайд-владелец слайда s.slide;
     sX sY   - значения x, y-координат привязки слайда.

     SLIDE_XY_SET - устанавливает  новую привязку для слайда
s.slide,  при которой  первая ячейка  его видеобуфера  будет
иметь координаты (sX sY).

     SLIDE_OWNER  -  возвращает   ссылку  на  слайд-владелец
s.owner  слайда  s.slide.  И  кроме  этого координаты первой
ячейки  видеобуфера s.slide,  взятую как  ячейку видеобуфера
s.owner, с использованием его привязки.

     В  частности,  если  s.slide  -  первичный  слайд, т.е.
владелец  самого  себя,  то  функция  SLIDE_OWNER  вернет  в
качестве результата s.slide sX sY,  где sX и sY - координаты
левого верхнего угла s.slide.


             Функции работы с прямоугольниками
             ═════════════════════════════════

     При описании  функций по работе со  слайдами или окнами
часто использовалось понятие прямоугольник или прямоугольник
слайда. Кроме  этого утверждалось, что  класс SLIDE является
подклассом  класса  RECT.  Опишем  теперь  этот  класс и его
функции-методы.

     Объект  класса  RECT  характеризуется  четырьмя  целыми
числами:

sX sY - координаты левого  верхнего  угла  прямоугольника  в
        некоторой "глобальной системе координат;
sW sH - ширина и высота прямоугольника, причем, если хотя бы
        одна из этих величин  не положительна, то считается,
        что прямоугольник пустой.

     Представление объекта класса RECT может быть разное:

как значение - (sX sY sW sH) или через ссылку - s.rect.

     В    последнем   случае    получить   значение   чисел,
характеризующих прямоугольник можно вызвав функцию RECT_GET:

     <RECT_GET s.rect> == (sX sY sW sH)

     Обобщая    оба    эти    представления,   далее   будет
использоваться t.rect для обозначения объекта класса RECT.


             Функции доступа к прямоугольникам
             ─────────────────────────────────

     <RECT_GET   t.rect>         == (sX sY sW sH)
     <RECT_SET   s.rect t.rect1> ==
     <RECT_EMPTY t.rect>         == T | F
@CP 6
где
     t.rect  -  прямоугольник,   к  которому  осуществляется
                доступ;
     s.rect  -  ссылка на объект класса RECT;
     t.rect1 -  прямоугольник,  задающий  новую  привязку  и
                размеры для s.rect.

     RECT_GET - возвращает терм  (sX sY sW sH), определяющий
прямоугольник t.rect.

     RECT_SET - устанавливает новую привязку  и  размеры для
прямоугольника s.rect.

     RECT_EMPTY   -  возвращает   слово  "T"   или  "F",   в
зависимости от того пуст или нет прямоугольник t.rect.


           Функции-конструкторы прямоугольников
           ────────────────────────────────────

     <RECT_INTRS t.rect1 [t.rect2 ...]> == (sX sY sW sH)
     <RECT_UNION t.rect1 [t.rect2 ...]> == (sX sY sW sH)
     <RECT_SUBTR t.rect1 [t.rect2]>     == (e.up)
                                           (e.left)
                                           (e.right)
                                           (e.bottom)
где
     t.rect1 - первый прямоугольник-аргумент функции;
     t.rect2 - второй прямоугольник-аргумент функции;
     (e.xxx) - прямоугольники,заданные в форме (sX sY sW sH)
                    определяющие соответственно:  верхний, левый,
               правый и нижний прямоугольник разности.

     RECT_INTRS   -   возвращает   значение  прямоугольника,
являющегося  пересечением   всех  прямоугольников-аргументов
функции.  При  этом,  если  пересечение  пусто,  то выдается
пустой прямоугольник.

     RECT_UNION   -   возвращает   значение  прямоугольника,
являющегося "наименьшим" прямоугольником,  содержащим в себе
все прямоугольники-аргументы  функции. При этом,  если среди
аргументов  встретились  пустые  прямоугольники,  они просто
игнорируются.  Пустой  прямоугольник  получается  в качестве
результата  только  тогда,  когда  все  аргументы  -  пустые
прямоугольники.

     RECT_SUBTR     -     возвращает     значения    четырех
прямоугольников,  задающих  область,  являющуюся результатом
вычитания    прямоугольника    t.rect2    из    t.rect1    в
теоретико-множественном   смысле.   Разность   строится   по
следующей схеме:
@CP 14

╔═ t.rect1 ════════════════════════════════════════════════╗
║                                                          ║
║                          (e.up)                          ║
║                                                          ║
╟────────────────╥────────────────────────╥────────────────╢
║                ║                        ║                ║
║   (e.left)     ║         t.rect2        ║   (e.right)    ║
║                ║                        ║                ║
╟────────────────╨────────────────────────╨────────────────╢
║                                                          ║
║                        (e.bottom)                        ║
║                                                          ║
╚══════════════════════════════════════════════════════════╝

     Если  прямоугольник t.rect2  не лежит  полностью внутри
прямоугольника    t.rect1,    то    какие-то    из   четырех
прямоугольников  в результате  вырождаются в  пустые (но они
все равно выдаются функцией).

     Если прямоугольник t.rect2  пуст или вообще отсутствует
при  вызове функции,  то  возвращается  в качестве  (e.up) -
значение  t.rect1, а  остальные прямоугольники, составляющие
результат - пустые. Если  прямоугольник t.rect1 пуст, то все
прямоугольники в результате тоже пустые.


               Функции работы с клавиатурой
               ════════════════════════════

     Клавиатура  представляется   автоматически  создаваемым
объектом *STDKEY класса KEY, который в свою очередь является
подклассом  класса  CHANNEL.  Т.е.  клавиатура  -  это канал
посимвольного ввода.

     В отличии от канала *STDIN клавиатура на запрос символа
ожидает нажатия клавиши и возвращает  один или два символа в
зависимости от того, нажата  обычная или специальная клавиша
(F1,  F2, ...,  стрелки и  т.д.). В  последнем случае первым
символом  возвращается   символ-литера  с  кодом   0,  а  на
повторный  запрос  -  scan-код  нажатой  клавиши. Если буфер
клавиатуры  пуст, то  функция ожидает  пока не  будет нажата
клавиша. Это  отличается от ввода символа  из канала *STDIN,
у которого запрос удовлетворяется  только после ввода строки
полностью, т.е. после нажатия клавиши <Enter>.

     Узнать пуст ли буфер клавиатуры можно с помощью функции
KEY_PRESSED.  Это важная  функция, т.к.  вызов <EOF *STDKEY>
всегда  для клавиатуры  будет возвращать  слово "F"  (ввод с
клавиатуры ничем не ограничен).

     Для  программирования  удобно,  когда  по нажатию любой
клавиши возвращается  ровно одно число  - ключ клавиши.  Для
этого существует  функция KEY_READ, которая  ожидает нажатие
клавиши  на  клавиатуре   и  возвращает  символ-число.  Ключ
клавиши строится следующим образом:

для обычной клавиши     - это ее ASCII-код (от 0 до 255);
для специальной клавиши - это ее scan-код, взятый со знаком
                          минус.

     Клавиатура имеет  буфер для возвращения  "в нее" одного
символа или  ключа клавиши с  помощью функции KEY_UNREAD.  И
когда в следующий раз будет запрошен с клавиатуры символ или
ключ  клавиши,   то  будет  возвращен   результат  с  учетом
последнего вызова функции KEY_UNREAD.

     Чтение  символов или  ключей клавиш  с клавиатуры  и их
обратный  возврат  взаимно   согласован.  Т.е.  можно  назад
вернуть  ключ клавиши  (даже специальной),  а прочесть потом
соответственно один  (или два) символа  функциями канального
ввода.  KEY_UNREAD  правильно  проинтерпретирует  и  возврат
символа с кодом 0, и возврат числа - ключа клавиши.


                     Описание функций
                     ────────────────

     <KEY_READ>          == s.key
     <KEY_UNREAD s.char> ==
     <KEY_PRESSED>       == T | F
где
     s.key   - символ-число - ключ введенной клавиши;
     s.char  - символ-литера или символ-число (s.key).

     KEY_READ - с клавиатуры считыватеся "нажатие клавиши" и
возвращается символ-число - ключ клавиши. Для обычных клавиш
это просто ASCII-код соответствующего символа (от 0 до 255),
а для специальных клавиш типа стрелок или Fxx - это scan-код
этой клавиши взятый со знаком минус.

     KEY_UNREAD  -  возвращает  в  буфер  клавиатуры нажатие
одной клавиши. Нажатие клавиши  может быть представлено либо
символом-числом,  тогда считается,  что это  - ключ клавиши,
либо  просто  символом  литерой.  Для  "возвращения" в буфер
клавиатуры  специальной  клавиши   необходимо,  либо  считав
нажатие  этой  клавиши  полностью   (при  вводе  -  это  два
символа), "вернуть" в буфер  ключ этой клавиши, либо, считав
символ-литеру с кодом 0, тут же "вернуть" этот символ.

     KEY_PRESSED  -   возвращает  слово  "T",   либо  "F"  в
зависимости от того есть ли символы в буфере клавиатуры. При
этом учитывается и предыдущий вызов функции KEY_UNREAD, т.е.
после вызова KEY_UNREAD KEY_PRESSED всегда выдаст "T".
