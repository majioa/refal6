                 R E F A L - 6

             OPERATING INSTRUCTIONS

       Copyright (C) 1993 by Arkady Klimov

CONTENTS

1. List of files

2. How RI.EXE works

3. What i.rex does

4. Compiling Refal to RASL

5. Debugging

6. The new Refal-6 input form

7. How to install the Refal-6 system

____________________________________________________________________________

   1. List of files

Executables:
   ri.exe          - RASL-interpreter for Windows
   rig.exe         - - " - for DOS (with graphics)
   ri32.exe        - - " - for DOS-extender (w/o graphics)

Batch files:
   ri.bat       - == ri.exe, common part of other bat's
   rfc.bat      - a Refal-RASL compiler
   rf6.bat      - -"- for new Refal-6 input form
   rfl.bat      - compiler for listing files
   rfi.bat      - call refal interpreter
   rfi5.bat     - call refal interpreter for Refal-5

Refal-Executable files:
   i.rex       - system initiator
   c.rex       - compiler Refal - RASL (works under i.rex)
   default.rex - shows help information
   rssynt.rex, rccomp.rex - dynamically loaded parts of compiler
   rssynt6.rex - a version of rssynt.rex (for new Reafal-6 syntax)
   tr.rex      - tracing/breakpoint facility

Built-in function list files:
   builtin.fls - the list of built-in functions (used by rfc)

Miscelaneous
    altern.*   - fonts for rig.exe

Text files:
   readme.txt   - this file
   refal.txt    - brief formal description of Real-6
   reflib.txt   - brief description of library functions
   video.txt    - description of graphic functions (for DOS version rig.exe)
____________________________________________________________________________

   2. How RI.EXE works

The target language of the REFAL compiler is called RASL.
RI is a RASL interpreter.
It can execute RASL programs, produced by the REFAL-RASL compiler.
RASL programs are text files which can be executed by RI.
The REFAL - RASL compiler makes one REX file for each REF file.
Each Refal function definition is translated into one line of the REX file,
which defines internal function object with the same name.
Each function is translated independently from others.
An object definition is translated into object definition in the REX file.
A directive  $EXEC F arg;  is translated into the active expression  <F arg> .

The RI has a single input stream which contains a sequence of
expressions and object definitions. Expressions may contain
function calls. The 1-st parameter of the command line is
a list of files which is fead as input to RI,
e.g. "ri file1+file2+file3". The extension REX is used by default here.
If the 1-st parameter is empty, the default file is "default.rex".
Actually, ri.exe itself takes only the first file of the sum, here file1.rex,
and inputs it. It is the responsibility of this file to input all others.

Each object definition has a name, a type and a body. The syntax is:
     *name=tnnn(body)
where
  t is a type symbol (e.g. F for functions);
  nnn is an optional size of the body (number of 0-terms);
  body is a ground refal expression (either active or passive)

When any necessary file cannot be found in the current directory
the run-time system looks for it in the directory the program RI.EXE
was taken from.

Special kind of parameters of the form: -x... are intended for the
interpreter RI.EXE itself. These are:
    -Snnn - transition stack size is nnn, the default value is 640 items
(records, each being an array of 4 pointers to element);
    -Tnnn - element table size is nnn, the default value is 2048
(pointers to element);
    -Bnnnnn - size of memory block:
             SPLIT model - total number of elements;
            LARGE model - number of elements in each block;
    -Hnnn - total size of Heap in Kbytes (optionally either all of the
free memory or about 4MB);
    -r - enables printing out the result of each input expression
to the standard input stream;
    -s - enables printing out the execution information (covers -r);
Large transition stack and element table are needed when your program
has a non-tail recursion, otherwise  the numbers of 200 and 500
are large enough. (Tail recurtion is a recursion in the last expression
of the path, provided that fails are blocked by "=").
    -Wnn - the width of page for pretty output of refal expression,
by default 79. Set -W0 to disable pretty output of expressions.``
____________________________________________________________________________






3. What i.rex does

Using the name 'i' as the first file name (e.g. ri i+file1+file2)
yields some additional functionality which follows.

All other files may have module structure. It means that only few
specified functions become visible from the outside. Such files are
generated by the compiler if the source file contains
structure directives ($MODULE-$END) or at least one defined external
object (on the top level of module structure).

Each input expression may contain reference to object of the form *name,
which denotes the (reference to) named object. This object can be defined
either before or after the reference is met. In any case the reference
should be resolved properly via the current table.
Initially the current table is *SYSTABLE, which defines
the global environment, i.e. the set of all ENTRY and/or EXTERN
functions (including library functions).

All functions defined in the initial REX-file become accessible via the
global environment. To make local functions invisible from the outside
the concept of module has been introduced.

Each module has a headder which specifies its EXTERNal objects.
(ENTRY function is a particular case of external object).
Only these objects are accessible via the global environment.
All other objects (functions) of the module are resolved
via the local environment (table) of this module.
This table disappears immediately after the loading
unless the module contains the reference symbol *THISTABLE.

The initiator i takes user modules first from the continuation of itself,
and second from the list in the command line in the form:
         ri i+mod1+mod2+...+modk+@ask  args
(the extension REX is default here).

An element @name (or *name) may be used instead of filename, which denotes
the invocation of <NAME> (where NAME is the uppercased version of name)

A function ASK initiates an input loop,
in which it prompts (by prompt '#>') a command of the form
        Fun Argument
The system evaluates the function call <FUN Argument>,
prints the result and loops back to the prompt.
To end the session enter Ctrl+Z <ENTER>.

The user module can start execution itself by the directive
      $EXEC fun arg ;

Each part of ther sum f1+f2+...fN if the command linew
may be replaced by the single file name fff, which is obtained by
    copy f1.rex+f2.rex+...+fN.rex fff.rex
____________________________________________________________________________







   4. Compiling Refal to RASL


To compile your module user.ref enter the command
        ri i+c+@go user {/switch}
Since there is a batch file rfc.bat use shorter version
        rfc user { /switch }

Switch /l yields the listing of the source program user.rfl with
error messages.

The listing contains the source lines interleaved with error messages.
It is a good idea to use the listing instead the source text to
correct errors. Eliminate errors and messages by any editor you like
and enter the command
         rfl user
It copies the file user.rfl to user.ref and recompiles it.
Repeat this loop until the successful compilation.

Enter the command
        rfc
to get more help on compilation.

To produce a readable version of the file user.rex (not executable one)
use the command
        rfc user /S /Xsss
Now the file user.sss will be produced which contains symbolic RASL codes
instead of genuine codes.

To compile your file "f.ref" from the dialog mode
use the command (i.e. Refal function) COMP:
comp f

Use compiler switches enclosed in doublequotes, e.g.:
comp f "/S" "/Xxxx" "/L"
If none of switches is specified the old switches are preserved.

To load the compiled module dynamically use function LOAD:
load f

To compile the file f just to the memory use function CL (Comp & Load):
cl f

To invoke any external function FUN of your module use the form:
fun arg

If your functon name contains lower case letters use the form:
*Fun arg

(note that Fun is a word whereas *Fun is a reference symbol).

To delete your module from memory use the command DELETE:
delete f     - if the file "f.rex" was loaded
delete "f."  - if the file "f.ref" was compiled to memory

____________________________________________________________________________




    5. Debugging

The process of program evaluation divides naturally into steps.
A step starts when function call is activated. (Resuming of function body
after evaluation of subexpression is also regarded as the beginning
of the new step.)
The process can be broken at the beginning of each step.
There are several methods to break the process:

    1. Break on Ctrl+C. If the user press Ctrl+C, the program will break
at the beginning of the next step.

    2. Break on <BREAK>. The standard function call <BREAK> implies that
program breaks at the beginning of the next step. The facility of
break point (see below) makes use of this method.

    3. Break on step. The number of steps specified in commands S and T
(see below) is exhausted.

    4. Break on evaluation termination. This break occurs after commands
E, C or N (see below).

    5. Break on $FAIL. If an error occur, then the program breaks
at the beginning of the current step. In this case the user can not
restart process of evaluation of the current active term.

When program breaks a prompt displays on the console. The user
should answer by pressing a single key. The menu contains following options
(the case does not matter):

A - display Active term (and repeat the prompt).

V - display the View field (and repeat the prompt).

F - display Free storage as it is. (For experienced users)

R - Run (continue) the process. If the tracing is ON each step should be
    displayed on the console in the form:

    Step # NNNN
    AT: <F arg>  (active term) or [F arg] (fail-able active term)
    RES: expr    (result of step = the first expression on the path
                  to evaluate)

[n]S - switch tracing OFF and make n Steps. By default n=1.

[n]T - switch Tracing ON and make n steps. By default n=1.

E - evaluate current active term (with or without tracing) and break.
    The result of evaluation displays in the form
    E-RES: object-expression

N - enter New view field aside of the old one.
    The expression is prompted, user enters expression, on <ENTER>
    the expression evaluation starts. The evaluation process level
    increments by 1. When it stops, the result displays on the console,
    and the old process prompts again.



C - Change active term to another (possibly active) expression.
    The same as N, but the result replaces the active term of the old process.

I - display system Information (step number and other interpreter's variables).

M - display Memory usage information. (For experienced users)

W - display Word hash table. (For experienced users)

D - redirect all debugging output to Disk file. The file name is prompted.
    This option is useful in graphic mode. The option of filename prn is
    also valuable.

L - cLear the screen. This option is useful in graphic mode.

Q - quit the program. On the prompt "Exit? Y/N/P" answer Y, if you wish
    to return to DOS, answer N if you wish return back, and answer P (partly)
    to exit only from the current level of the interpreter.

Several functions are designed specially for the use in the
expressions prompted by command N:

<BRK list-of-names>
    The argument is a list of function names (optionally without *).
    Their bodies change so that a break occurs at each call of them.

<TRC list-of-names>
    The argument is a list of function names (may be without *).
    Their bodies change so that for each call:
    the function name, the argument and the current step
    are displayed in the start of evaluation, and
    the function name, the result and the current steps of both start and end
    are displayed in the end of the evaluation of the call.
    Using current steps it is easy to relate each call to its result.

    Use also function GETV to inspect the state of any box.


____________________________________________________________________________

   6. The new Refal-6 input form

   The new Refal-6 input form of the source program has the following
peculiarities (enabled by switch /Y6):
    1. The following rule for types of variables is used:
-----------------------------------------------------------------------
     Variable type            | The starting letter of the variable
-----------------------------------------------------------------------
 term (symbol or              | any lower case letter
       expression in brackets)|     (examples: x, y, a1, table)
                              |
 expression (list)            | sign "_" (examples: _a, _tail , _1, _)
                              |
 symbol (atom)                | sign "." (examples: .s, .1, .ref, .)
-----------------------------------------------------------------------
    2. The /U switch of the compiler (Upcase all names) does not work,
i.e. the case always matters.

____________________________________________________________________________





   7. How to install the Refal-6


1. Unpack the file REF.ZIP into a new directory, say C:\REFAL6

2. In ri.bat file enscribe correct full path (C:\REFAL6\) before the program name 'ri.exe'
   (otherwise auxiliary files won't load in Windows 95/NT)

3. Move all *.bat files into directory, which is in the PATH, e.g. C:\BAT, C:\BIN.

Now you may use commands ri, rfc, rfi, etc. from either working directory.





____________________________________________________________________________

(This file is formatted to be printed with 60 lines per page)
